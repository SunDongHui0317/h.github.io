<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法导论 on ∞</title>
    <link>https://sundonghui0317.github.io/h.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</link>
    <description>Recent content in 算法导论 on ∞</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://sundonghui0317.github.io/h.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法导论学习笔记（1）</title>
      <link>https://sundonghui0317.github.io/h.github.io/post/introduction-to-algorithms-mit-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sundonghui0317.github.io/h.github.io/post/introduction-to-algorithms-mit-01/</guid>
      <description>《算法导论》一共包含两部分，即算法分析和算法设计。
什么是算法分析？ “算法分析是关于计算机程序性能和资源利用的理论研究。”
可以理解为，算法的主要目的是为了提升性能和资源利用，那么，在程序设计方面，有没有比性能更重要的呢？当然有，正确性、简洁性、稳定性、安全性、可扩展性、功能性、可维护性、模块化、用户体验等等，在程序设计方面都很重要，那么，为什么要学习算法呢？
为什么要学习算法呢？ 有以下三点理由：
在绝大多数情况下，性能的好坏会直接决定方案的可实施性。 算法是计算机科学领域中描述程序行为的语言，是一种让程序更为简洁的思考方式，其所扮演的角色就如同经济中的货币。 有趣。（有趣的定义千差万别，有趣的事情千人千面） 复杂度分析的一些概念 基本操作：内存引用计数，即程序实际上访问了某个变量多少次。 最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度。这是分析中最常用的指标。 最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。事实上，这通常被认为是一种假象，因为最好情况下的输入是特定的，并不能真正检验程序的实际表现，而且很容易“作弊”。 平均时间复杂度：代码在所有情况下出现的概率的加权平均值。在一些情况下，会使用这项指标。这里其实还有一个问题，即如何知道各种情况出现的概率？答案是做一个输入统计分布的假设，最常见的输入统计分布的假设是所有输入以等可能性的方式出现，即均匀分布。 渐近分析：基本思路有两点：1.忽略掉那些依赖于机器的常量；2. 不是去检查实际的运行时间，而是去关注运行时间的增长。渐近分析的结果用渐近符号 Θ（与其说它是一个运算符，不如说它是一个描述符）表示，Θ 的计算方式为丢弃低阶项，并忽略前面的常数因子，这里有一个例外，就是当数据量 n 很大，大到计算机无法运行该算法时，一些相对低速的算法可能更好，因为它们在合理规模的输入下运行得更快。因此，我们需要在数学理解和和工程直觉之间做出权衡，才能写出好用的程序。 插入排序 插入排序将数据分为两个区间，已排序区间和未排序区间。核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。插入排序的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，是一个原地排序算法。
Go 语言实现如下：
// 插入排序 func insertionSort(list []int) []int { n := len(list) a := make([]int, n, n) copy(a, list) // 不改变原切片值 if n &amp;lt;= 1 { return a } for i := 1; i &amp;lt; n; i++ { v := a[i] j := i - 1 for ; j &amp;gt;= 0; j-- { if a[j] &amp;gt; v { a[j+1] = a[j] } else { break } } a[j+1] = v } return a } 归并排序 归并排序有三个步骤：</description>
    </item>
    
  </channel>
</rss>
